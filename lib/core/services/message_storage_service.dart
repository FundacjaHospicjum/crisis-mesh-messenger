import 'package:hive_flutter/hive_flutter.dart';
import 'package:logger/logger.dart';
import '../models/message.dart';
import '../models/peer.dart';
import '../models/conversation.dart';

/// Service for persistent message and conversation storage
class MessageStorageService {
  final Logger _logger = Logger();
  
  static const String _messagesBoxName = 'messages';
  static const String _conversationsBoxName = 'conversations';
  
  Box<Message>? _messagesBox;
  Box<Conversation>? _conversationsBox;

  /// Initialize Hive and open boxes
  Future<void> initialize() async {
    _logger.i('Initializing message storage...');
    
    await Hive.initFlutter();
    
    // Register adapters (generated by hive_generator)
    if (!Hive.isAdapterRegistered(0)) {
      Hive.registerAdapter(MessageAdapter());
    }
    if (!Hive.isAdapterRegistered(1)) {
      Hive.registerAdapter(PeerAdapter());
    }
    if (!Hive.isAdapterRegistered(2)) {
      Hive.registerAdapter(ConversationAdapter());
    }
    if (!Hive.isAdapterRegistered(3)) {
      Hive.registerAdapter(MessageStatusAdapter());
    }
    if (!Hive.isAdapterRegistered(4)) {
      Hive.registerAdapter(PeerStatusAdapter());
    }
    
    // Open boxes
    _messagesBox = await Hive.openBox<Message>(_messagesBoxName);
    _conversationsBox = await Hive.openBox<Conversation>(_conversationsBoxName);
    
    _logger.i('Message storage initialized');
  }

  /// Save a message
  Future<void> saveMessage(Message message) async {
    if (_messagesBox == null) {
      throw StateError('MessageStorageService not initialized');
    }
    
    await _messagesBox!.put(message.id, message);
    _logger.d('Message saved: ${message.id}');
  }

  /// Get a message by ID
  Message? getMessage(String messageId) {
    if (_messagesBox == null) return null;
    return _messagesBox!.get(messageId);
  }

  /// Get all messages for a conversation
  List<Message> getMessagesForConversation(String peerId, String currentUserId) {
    if (_messagesBox == null) return [];
    
    return _messagesBox!.values
        .where((msg) =>
            (msg.senderId == currentUserId && msg.recipientId == peerId) ||
            (msg.senderId == peerId && msg.recipientId == currentUserId))
        .toList()
      ..sort((a, b) => a.timestamp.compareTo(b.timestamp));
  }

  /// Get recent messages (for debugging/overview)
  List<Message> getRecentMessages({int limit = 50}) {
    if (_messagesBox == null) return [];
    
    final messages = _messagesBox!.values.toList()
      ..sort((a, b) => b.timestamp.compareTo(a.timestamp));
    
    return messages.take(limit).toList();
  }

  /// Delete a message
  Future<void> deleteMessage(String messageId) async {
    if (_messagesBox == null) return;
    
    await _messagesBox!.delete(messageId);
    _logger.d('Message deleted: $messageId');
  }

  /// Delete all messages in a conversation
  Future<void> deleteConversationMessages(String peerId, String currentUserId) async {
    if (_messagesBox == null) return;
    
    final messages = getMessagesForConversation(peerId, currentUserId);
    for (final message in messages) {
      await _messagesBox!.delete(message.id);
    }
    
    _logger.i('Deleted ${messages.length} messages for conversation with $peerId');
  }

  /// Save a conversation
  Future<void> saveConversation(Conversation conversation) async {
    if (_conversationsBox == null) {
      throw StateError('MessageStorageService not initialized');
    }
    
    await _conversationsBox!.put(conversation.id, conversation);
    _logger.d('Conversation saved: ${conversation.peerName}');
  }

  /// Get a conversation by ID
  Conversation? getConversation(String conversationId) {
    if (_conversationsBox == null) return null;
    return _conversationsBox!.get(conversationId);
  }

  /// Get conversation by peer ID
  Conversation? getConversationByPeer(String peerId) {
    if (_conversationsBox == null) return null;
    
    return _conversationsBox!.values
        .where((conv) => conv.peerId == peerId)
        .firstOrNull;
  }

  /// Get all conversations
  List<Conversation> getAllConversations() {
    if (_conversationsBox == null) return [];
    
    final conversations = _conversationsBox!.values.toList()
      ..sort((a, b) {
        // Pinned conversations first
        if (a.isPinned && !b.isPinned) return -1;
        if (!a.isPinned && b.isPinned) return 1;
        // Then by last message time
        return b.lastMessageTime.compareTo(a.lastMessageTime);
      });
    
    return conversations;
  }

  /// Delete a conversation
  Future<void> deleteConversation(String conversationId) async {
    if (_conversationsBox == null) return;
    
    await _conversationsBox!.delete(conversationId);
    _logger.d('Conversation deleted: $conversationId');
  }

  /// Update conversation with new message
  Future<void> updateConversationWithMessage(
    Message message,
    String currentUserId,
    String peerName,
  ) async {
    final peerId = message.senderId == currentUserId 
        ? message.recipientId 
        : message.senderId;
    
    var conversation = getConversationByPeer(peerId);
    
    if (conversation == null) {
      // Create new conversation
      conversation = Conversation(
        id: 'conv_$peerId',
        peerId: peerId,
        peerName: peerName,
        lastMessageTime: message.timestamp,
        lastMessagePreview: message.content,
        unreadCount: message.recipientId == currentUserId ? 1 : 0,
      );
    } else {
      // Update existing conversation
      conversation = conversation.updateWithMessage(message, currentUserId);
    }
    
    await saveConversation(conversation);
  }

  /// Mark conversation as read
  Future<void> markConversationAsRead(String conversationId) async {
    final conversation = getConversation(conversationId);
    if (conversation != null) {
      await saveConversation(conversation.markAsRead());
    }
  }

  /// Get total unread count
  int getTotalUnreadCount() {
    if (_conversationsBox == null) return 0;
    
    return _conversationsBox!.values
        .fold(0, (sum, conv) => sum + conv.unreadCount);
  }

  /// Clear all data (for testing/reset)
  Future<void> clearAll() async {
    await _messagesBox?.clear();
    await _conversationsBox?.clear();
    _logger.w('All message data cleared');
  }

  /// Close boxes
  Future<void> close() async {
    await _messagesBox?.close();
    await _conversationsBox?.close();
    _logger.i('Message storage closed');
  }
}
